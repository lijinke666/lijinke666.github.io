<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="李金珂,jinke.li666@gmail.com"><title>Canvas 文本渲染那些事 · 李金珂的小屋</title><meta name="description" content="背景在表格细分领域中，主要的技术实现分为 DOM 和 Canvas, 满足不同的使用场景，各有优劣，DOM 更灵活更方便，很多事情浏览器渲染引擎已经帮你处理好了，缺点是性能较差，交互实现不灵活，Canvas 解决了 DOM 的缺点，但是也带来更高的上手成本和开发难度，本文就着重讲解使用 Canvas"><meta name="keywords" content="Javascript,Node.js"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="李金珂的小屋"><meta name="icon" content="/logos/logo_192.png"><meta name="apple-touch-icon" content="/logos/logo_192.png"><meta name="apple-touch-icon-precomposed" content="/logos/logo_192.png"><meta name="apple-touch-startup-image" content="/logos/logo_192.png"><meta name="Alipay:title" content="李金珂的小屋"><meta name="Alipay:imgUrl" content="/logos/logo_192.png"><meta name="Alipay:desc" content="要想学仙术哪能不吃苦"><meta name="renderer" content="webkit"><meta name="theme-color" content="#fff"><link rel="short icon" href="/logos/logo_192.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="manifest" href="/manifest.json"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/my.jpeg" style="width:127px;border-radius:50%;margin-bottom:20px;"><h3 title=""><a href="/">李金珂的小屋</a></h3><div class="description"><p>要想学仙术,哪能不吃苦</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://weibo.com/金珂珂珂珂"><i class="fa fa-weibo"></i></a></li><li><a target="_blank" rel="noopener" href="http://github.com/lijinke666"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by</span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai</a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a><a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备17033638号</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">主页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友情链接</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/my.jpeg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Canvas 文本渲染那些事</a></h3></div><div class="post-content"><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在表格细分领域中，主要的技术实现分为 DOM 和 Canvas, 满足不同的使用场景，各有优劣，DOM 更灵活更方便，很多事情浏览器渲染引擎已经帮你处理好了，缺点是性能较差，交互实现不灵活，Canvas 解决了 DOM 的缺点，但是也带来更高的上手成本和开发难度，本文就着重讲解使用 Canvas 实现 S2 表格在文本渲染上遇到的那些事。</p>
<h3 id="GgCc9">让文本渲染更清晰</h3>

<p><code>DPR</code>是 “Device Pixel Ratio”（设备像素比）的缩写，指的是物理像素和设备独立像素的比率，不同的屏幕 <code>DPR</code>也不同，像我们平时用的 <strong>2k 外接屏 DPR</strong> 是 <code>1</code>, <strong>Mac 视网膜屏幕</strong> DPR 是 <code>2</code>.</p>
<table>
<thead>
<tr>
<th><img src="/images/2024-12-31-e0289d921ef67c663564ffe0d9094560667c799c1a86a3c408e973d0369ee454.png" alt="图 0"></th>
<th><img src="/images/2024-12-31-34d9147a43aea40955c2db4743c0c835bc1f5ce19662ba2fc8d96d553d2833c7.png" alt="图 1"></th>
</tr>
</thead>
</table>
<p>在 Canvas 中需要额外适配，不然文本，图形等场景会模糊，也就是将 <code>canvas</code> 的宽高放大 n 倍 (n = DPR)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;your-canvas-id&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> rect = canvas.getBoundingClientRect();</span><br><span class="line">canvas.width = rect.width * dpr;</span><br><span class="line">canvas.height = rect.height * dpr;</span><br><span class="line">ctx.scale(dpr, dpr);</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillText(<span class="string">&#x27;哈哈&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>:::warning<br>需要特别注意的是 <code>canvas.style.width</code> 和 <code>canvas.width</code> 是不同的，一个是 Canvas DOM 节点的 <code>width</code> 属性，一个是 CSS 样式，有本质上的区别。高清适配改变的是 <code>canvas.width</code>, 所以 DOM 的尺寸是不变的，<strong>不会影响页面布局。</strong></p>
<p>:::</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.style.width = xxx</span><br><span class="line">canvas.width = xxx</span><br></pre></td></tr></table></figure>

<p><img src="/images/2024-12-31-fd656246784f5ff2f918c4b0a3e073c32b0fdc13c2d3f3ee5a48988ce02ca9b6.png" alt="图 2"></p>
<p>除此之外，还有 <strong>DPR 切换的场景，</strong>比如用户将浏览器从 2K 显示器移动到的另外一个 4K 的显示器 🖥, 由于 Canvas 是按照移动前的屏幕 DPR 进行的适配，所以也会有模糊的问题，解决的方法是通过 <code>matchMedia</code> 对 DPR 进行监听，重新更新 <code>canvas.width/height</code> 即可。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// devicePixelRatio: 1</span></span><br><span class="line"><span class="keyword">const</span> media = <span class="built_in">window</span>.matchMedia(<span class="string">`(resolution: <span class="subst">$&#123;<span class="built_in">window</span>.devicePixelRatio&#125;</span>dppx)`</span>);</span><br><span class="line"></span><br><span class="line">media.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>; <span class="comment">// devicePixelRatio: 2</span></span><br><span class="line"></span><br><span class="line">  canvas.width = rect.width * dpr;</span><br><span class="line">  canvas.height = rect.height * dpr;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Xw9wh">文本排版与换行</h3>

<h4 id="BafmC">排版</h4>

<p>在 Canvas 中要进行文字的排版和换行并不是一件容易的事，如果是 DOM, 我们通过编写简单的 <code>CSS</code> 就可以实现布局，浏览器已经帮我们计算好了一切，但在 Canvas 画板中，所有元素都是需要自己计算的，文本 (Text), 边框 (Line), 单元格 (Rect) 所有的一切。可以理解所有元素都是<strong>绝对定位</strong>, 要手动控制所有元素的 <code>top/right/bottom/left</code></p>
<p><img src="/images/2024-12-31-9b2849373160cedc205fa4b621cc411de776bf997fbf31b52630a13a86c27d64.png" alt="图 3"></p>
<p>如图所示，我们想绘制一个 <code>数量</code> 单元格，文本的右边，需要绘制一个 <code>▽</code> 排序 icon, 简化的步骤如下：</p>
<ul>
<li>计算出单元格的盒模型 (BBox), 类似与浏览器那样</li>
<li>计算出单元格的宽高和坐标 (x: 200, y: 100, width: 100, height: 30)</li>
<li>计算出 <code>数量</code> 文本的宽度，考虑文字的对齐方式 （靠左/居中/靠右） 后，计算文本坐标</li>
<li>计算出 <code>▽</code> icon 的宽高，考虑文本的 margin 和 padding 后，计算 icon 坐标</li>
</ul>
<p><img src="/images/2024-12-31-451a23757b3f315f55eab8f0181fb0a5536fc7f9e91ebabda4e3077aa158801c.png" alt="图 6"></p>
<p>由于还有滚动的场景，所以还需要额外考虑坐标的同步</p>
<p><img src="/images/2024-12-31-e29223c2b4c6fa85e821091c7da86bb8b12643724cd8fde11968fb36e7edfbb4.png" alt="图 7"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/antvis/S2/blob/a09d1fe0507a566f154a407c92f13ff48beafc99/packages/s2-core/src/cell/header-cell.ts#L48">S2/packages/s2-core/src/cell/header-cell.ts at a09d1fe0507a566f154a407c92f13ff48beafc99 · antvis/S2</a></p>
<p>对于 S2 这种单元格布局的场景，如果能像 CSS 那样使用 <code>flex</code> 或者 <code>grid</code>布局就非常的高效了，事实上，<font style="color:rgba(0, 0, 0, 0.85);">Facebook (Meta) 提供了跨平台布局引擎一个 </font><a target="_blank" rel="noopener" href="https://yogalayout.com/"><font style="color:rgba(0, 0, 0, 0.85);">Yoga</font></a><font style="color:rgba(0, 0, 0, 0.85);">, 可以实现类似的效果，如果写过 </font><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;React Native&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.85);">的同学肯定会很熟悉 </font></p>
<p><img src="/images/2024-12-31-4f1181e23cc323234bf2418a747aa49b496c333a0d0df5bdb05a036482ef6a2f.png" alt="图 8"></p>
<p><code>AntV/G 5.0</code> 也封装了相应的插件 <code>[g-plugin-yoga](https://g.antv.antgroup.com/plugins/yoga)</code> 不过由于历史原因和升级成本的问题，S2 没有迁移到该方案。</p>
<p><img src="/images/2024-12-31-738bd90dfeb0bfc6ee9bc77d5b2556de8187a2bfd892b977cc849f0c8cd9e327.png" alt="图 9"></p>
<h4 id="iolbI">文本省略</h4>

<p>解决了排版的问题，我们还需要考虑文本省略的场景，在 CSS 中，如果我们设置了 <code>text-overflow: ellipsis</code> 和 <code>overflow: hidden</code> 那么浏览器就会自动省略文本，并已 <code>...</code> 展示</p>
<p><img src="/images/2024-12-31-cef85a51127f058bb144ed03f33f66b0ca722c06cc1ec58260cd4283fee5e672.png" alt="图 10"></p>
<p>对于 S2 的表格场景，单元格的宽度是固定的，并默认就是溢出异常，所以需要计算是否需要展示省略号</p>
<p><img src="/images/2024-12-31-68da122f90460a708024a14564b405de12fd67aa099156933d5ef5f16a2d64bc.png" alt="图 11"></p>
<p>具体的实现感兴趣可以查看：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/antvis/S2/blob/ab0d0e768cf627249b38205b8c77d95a20b3a901/packages/s2-core/src/utils/text.ts#L193-L289">S2/packages/s2-core/src/utils/text.ts at ab0d0e768cf627249b38205b8c77d95a20b3a901 · antvis/S2</a></p>
<p>:::info<br>一个有趣的点是：按照浏览器的规范，当给定的宽度连省略号都不足以展示的话，会直接对文字进行截断，而不是显示 <code>...</code></p>
<p>:::</p>
<p><img src="/images/2024-12-31-1609f09856339f058ab06c7391a0430e122facaa1fde3d78cdf37732e41a48e2.png" alt="图 12"></p>
<h4 id="d90Ay">多行文本</h4>

<p><img src="/images/2024-12-31-770fad79165199f549a4350c3a923a9dae186d551a680a03618589795c0ffda7.png" alt="图 13"></p>
<p>在 CSS 中，我们可以通过 <code>line-clamp</code> 实现多行文本</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br></pre></td></tr></table></figure>

<p>对于 S2 的表格场景，单元格的宽度是固定的，以换两行为例：</p>
<ol>
<li>首先计算当前文本是否存在省略号</li>
<li>如果存在省略号，说明一行文字显示不下，那么进行分词</li>
<li>分词后，对第二行的文字进行相同的操作，第 n 行依次类推</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="title">drawTextShape</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x &#125; = <span class="built_in">this</span>.getContentArea();</span><br><span class="line">    <span class="keyword">const</span> &#123; y, height &#125; = <span class="built_in">this</span>.getCellArea();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> textStyle = <span class="built_in">this</span>.getTextStyle();</span><br><span class="line">    <span class="keyword">const</span> cornerText = <span class="built_in">this</span>.getCornerText();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当为树状结构下需要计算文本前收起展开的 icon 占的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> maxWidth = <span class="built_in">this</span>.getMaxTextWidth();</span><br><span class="line">    <span class="keyword">const</span> emptyPlaceholder = getEmptyPlaceholder(</span><br><span class="line">      <span class="built_in">this</span>.meta,</span><br><span class="line">      <span class="built_in">this</span>.spreadsheet.options.placeholder,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> &#123; measureTextWidth &#125; = <span class="built_in">this</span>.spreadsheet;</span><br><span class="line">    <span class="keyword">const</span> text = getEllipsisText(&#123;</span><br><span class="line">      measureTextWidth,</span><br><span class="line">      <span class="attr">text</span>: cornerText,</span><br><span class="line">      maxWidth,</span><br><span class="line">      <span class="attr">fontParam</span>: textStyle,</span><br><span class="line">      <span class="attr">placeholder</span>: emptyPlaceholder,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.actualText = text;</span><br><span class="line">    <span class="keyword">const</span> ellipseIndex = text.indexOf(ELLIPSIS_SYMBOL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> firstLine = text;</span><br><span class="line">    <span class="keyword">let</span> secondLine = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在文字的省略号 &amp; 展示为 tree 结构</span></span><br><span class="line">    <span class="keyword">if</span> (ellipseIndex !== -<span class="number">1</span> &amp;&amp; <span class="built_in">this</span>.spreadsheet.isHierarchyTreeType()) &#123;</span><br><span class="line">      <span class="comment">// 剪裁到 ... 最有点的后 1 个像素位置</span></span><br><span class="line">      <span class="keyword">const</span> lastIndex = ellipseIndex + (isIPhoneX() ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">      firstLine = cornerText.substr(<span class="number">0</span>, lastIndex);</span><br><span class="line">      secondLine = cornerText.slice(lastIndex);</span><br><span class="line">      <span class="comment">// 第二行重新计算。.. 逻辑</span></span><br><span class="line">      secondLine = getEllipsisText(&#123;</span><br><span class="line">        measureTextWidth,</span><br><span class="line">        <span class="attr">text</span>: secondLine,</span><br><span class="line">        maxWidth,</span><br><span class="line">        <span class="attr">fontParam</span>: textStyle,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">x</span>: textX &#125; = getTextPosition(</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">x</span>: x + <span class="built_in">this</span>.getTreeIconWidth(),</span><br><span class="line">        y,</span><br><span class="line">        <span class="attr">width</span>: maxWidth,</span><br><span class="line">        height,</span><br><span class="line">      &#125;,</span><br><span class="line">      textStyle,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> textY = y + (isEmpty(secondLine) ? height / <span class="number">2</span> : height / <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// first line</span></span><br><span class="line">    <span class="built_in">this</span>.addTextShape(</span><br><span class="line">      renderText(</span><br><span class="line">        <span class="built_in">this</span>,</span><br><span class="line">        [<span class="built_in">this</span>.textShapes[<span class="number">0</span>]],</span><br><span class="line">        textX,</span><br><span class="line">        textY,</span><br><span class="line">        firstLine,</span><br><span class="line">        textStyle,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// second line</span></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(secondLine)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.addTextShape(</span><br><span class="line">        renderText(</span><br><span class="line">          <span class="built_in">this</span>,</span><br><span class="line">          [<span class="built_in">this</span>.textShapes[<span class="number">1</span>]],</span><br><span class="line">          textX,</span><br><span class="line">          y + height * <span class="number">0.75</span>,</span><br><span class="line">          secondLine,</span><br><span class="line">          textStyle,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.actualTextWidth = max([</span><br><span class="line">      measureTextWidth(firstLine, textStyle),</span><br><span class="line">      measureTextWidth(secondLine, textStyle),</span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/antvis/S2/blob/ab0d0e768cf627249b38205b8c77d95a20b3a901/packages/s2-core/src/cell/corner-cell.ts#L76-L160">S2/packages/s2-core/src/cell/corner-cell.ts at ab0d0e768cf627249b38205b8c77d95a20b3a901 · antvis/S2</a></p>
<p>在 S2 2.0 中，得益与 G 5.0 渲染引擎的升级，内置了多行文本的能力，具体实现如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/antvis/G/blob/ee938ca12ac343d0506b7fa41bbd27d92fdd4d28/packages/g-lite/src/services/TextService.ts#L345">G/packages/g-lite/src/services/TextService.ts at ee938ca12ac343d0506b7fa41bbd27d92fdd4d28 · antvis/G</a></p>
<h3 id="BBofT">文本抗锯齿</h3>

<p>在游戏中，我们经常看到 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/442816681">垂直同步、动态模糊、抗锯齿</a> 这些关键词</p>
<p><img src="/images/2024-12-31-b653367d2b809d9c2d4fee33c0d343889aa61c49ca72409fa73cfb17e8a9e176.png" alt="图 14"></p>
<p>其中抗锯齿中的 “锯齿” 就像下图一样</p>
<p><img src="/images/2024-12-31-575a9ccd7b03d7fbfb1e42678eecf43d1885a2fb77fd2716849a6e7dc2b1f51a.png" alt="图 15"></p>
<p>如果用过 Windows “不知名软件” - “画图” 的话，画一条线就会看到下面这样</p>
<p><img src="/images/2024-12-31-4bc3e9bcc6b05291c3d58d22d0acf149e0dab2806fb1511d68a2bbefe61a3557.png" alt="图 16"></p>
<p><img src="/images/2024-12-31-811f8f1487604791fe13e5c727e0391f9c7debfab2423dc335fde8273212746f.png" alt="图 17"></p>
<p>在浏览器中，也会出现锯齿效果，专业名词叫<code>&lt;font style=&quot;color:rgb(27, 27, 27);&quot;&gt;anti-aliasing effect&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);"> , 不同的浏览器渲染引擎有不同的表现。</font></p>
<p><img src="/images/2024-12-31-7a9fbcbc3dc4111e7eb57aa2a89ca0c36e364b100011964703244ff6823b0335.png" alt="图 18"></p>
<p>浏览器允许我们写子像素，也就是 <code>width: 12px</code> <code>width: 12.3px</code> 都能正常渲染，每一个像素点可以看做一个正方形的格子，一旦文本边缘不再处于像素格网的整数位置，就会出现锯齿。要解决这个问题也很简单。对<strong>像素进行取整</strong>即可。</p>
<p>对于 CSS 可以开启 <code>-webkit-font-smoothing</code> 来优化</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.smoothed</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span><br><span class="line">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Canvas 中可以开启 <code>webkitImageSmoothingEnabled</code>来优化</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">ctx.webkitImageSmoothingEnabled = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>如果不开启抗锯齿的话，在 Canvas 中还会出现抖动的问题，可以点击下文了解更多</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/lijinke/blog/wes11u?singleDoc#">Canvas 浮点数坐标造成文字抖动的问题</a></p>
<h3 id="S5rba">文本宽高测量与字体的影响</h3>

<p>在表格渲染中，需要渲染大量的文本，需要计算文本的宽高用于布局坐标的计算，从而实现排版，宽度受浏览器的字体和符号影响</p>
<p>常见的文本有汉字，数字，英文，甚至 <code>Emoji 😸</code>, Emoji 通常是由多个 Unicode 字符组成的复合字符，宽度各不相同，那对于这种场景，如果我们想保证测量的宽度一致，那么可以使用 <code>[等宽字体](https://zh.wikipedia.org/zh-hans/%E7%AD%89%E5%AE%BD%E5%AD%97%E4%BD%93)</code></p>
<p><img src="/images/2024-12-31-b2cea509899a11666b3e2d3476c07fd306bfcf232b1b2863c6474c084f863f69.png" alt="图 19"><br><img src="/images/2024-12-31-cba70c4047295bce8a83a8b7f83bf4321e8c6e558a0d938884b365ec001c9d4e.png" alt="图 20"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JetBrains Mono, Fira Code, Source Code Pro,Menlo,FiraCode-Medium,FiraCode-Light,FiraCode-Light,<span class="string">&#x27;Courier New&#x27;</span>, monospace</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;your-canvas-id&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">ctx.font = <span class="string">&#x27;16px JetBrains Mono&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> textWidth = ctx.measureText(text).width;</span><br></pre></td></tr></table></figure>

<p>使用 Canvas Context 的 <code>measureText</code>, 获取到 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics">TextMetrics</a> 后，我们可以拿到相应的宽高，对于相同的文本，我们可以缓存起来，提高计算性能</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> measureText = memoize(</span><br><span class="line">   (text: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>, <span class="attr">font</span>: unknown): TextMetrics | <span class="function"><span class="params">null</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!font) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> ctx = <span class="built_in">this</span>.getCanvasElement()?.getContext(<span class="string">&#x27;2d&#x27;</span>)!;</span><br><span class="line">     <span class="keyword">const</span> &#123; fontSize, fontFamily, fontWeight, fontStyle, fontVariant &#125; =</span><br><span class="line">       font <span class="keyword">as</span> CSSStyleDeclaration;</span><br><span class="line"></span><br><span class="line">     ctx.font = [</span><br><span class="line">       fontStyle,</span><br><span class="line">       fontVariant,</span><br><span class="line">       fontWeight,</span><br><span class="line">       <span class="string">`<span class="subst">$&#123;fontSize&#125;</span>px`</span>,</span><br><span class="line">       fontFamily,</span><br><span class="line">     ]</span><br><span class="line">       .join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">       .trim();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ctx.measureText(<span class="built_in">String</span>(text));</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function">(<span class="params">text, font</span>) =&gt;</span> [text, ...values(font)].join(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> measureTextWidth = (</span><br><span class="line">   text: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">   <span class="attr">font</span>: unknown,</span><br><span class="line"> ): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> textMetrics = <span class="built_in">this</span>.measureText(text, font);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> textMetrics?.width || <span class="number">0</span>;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> measureTextHeight = (</span><br><span class="line">   text: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">   <span class="attr">font</span>: unknown,</span><br><span class="line"> ): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> textMetrics = <span class="built_in">this</span>.measureText(text, font);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!textMetrics) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent</span><br><span class="line">   );</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="EWruh">离屏 Canvas 与字体的影响</h3>

<p>通常我们说的 <code>离屏 Canvas</code> 是指没有 append 到 body 上 （用户不可见） 的 <code>Canvas</code>, 它存在于内存中，用于做一些复杂计算和绘制，在处理完成后，再绘制回原本的 Canvas, 以提升性能</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> offscreenCanvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ctx = offscreenCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在离屏 Canvas 上进行绘制操作</span></span><br><span class="line">ctx.fillStyle = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把离屏 Canvas 绘制到页面可见的 Canvas 上</span></span><br><span class="line"><span class="keyword">const</span> visibleCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;visibleCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> visibleCtx = visibleCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">visibleCtx.drawImage(offscreenCanvas, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现代浏览器也提供一个实现性的标准实现 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/OffscreenCanvas">OffscreenCanvas</a>, 由于不是本文重点，这里略过</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myEntity.offscreenCanvas = document.createElement(&quot;canvas&quot;);</span><br><span class="line">myEntity.offscreenCanvas.width = myEntity.width;</span><br><span class="line">myEntity.offscreenCanvas.height = myEntity.height;</span><br><span class="line">myEntity.offscreenContext = myEntity.offscreenCanvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">myEntity.render(myEntity.offscreenContext);</span><br></pre></td></tr></table></figure>

<p>由于离屏 Canvas 不存在文档流中，那么也会出现文本宽度测量不一致的问题，解决方法也很简单，将其添加到 body 中 （默认隐藏）, 即可得到一致的字体表现。</p>
<p><img src="/images/2024-12-31-1f885c962cc996040e0d217e39d4b12dfa575ac4fa6d1c388ab6f09bf6e8bae9.png" alt="图 21"></p>
<h3 id="M9QRd">文本无障碍体验</h3>
> 无障碍（Accessibility）是指为人们提供平等访问信息、服务和环境的设计理念和实践。在 Web 开发中，无障碍性是确保所有人，包括身体残障、认知障碍和感知障碍的人，都能够获得和使用网站和应用程序的能力。
>

<p>无障碍体验目前苹果做的最好，对于前端来说，很多组件库也做了一些无障碍的适配，比如 Ant Design</p>
<p><img src="/images/2024-12-31-0461b29167511db4969277a8cc1a8fb56523c2046ccb2909f5a9bb3daa4340c0.png" alt="图 22"></p>
<p>对于表格这类大量文字的场景，对于使用 Canvas 的表格的 S2 来说是一大痛点，比如文字无法被选中，无法被键盘访问，无法添加 <code>aria</code> 标签，无法被搜索等问题。同时对 SEO 也不友好。</p>
<p><img src="/images/2024-12-31-8ea497cf4f533368f93a2aa9eb1342e30992e62bef43a93d13f827248ec8a857.png" alt="图 23"></p>
<p>要解决这个问题，我们可以在 Canvas 的上方添加 DOM 蒙层，并解析 Canvas 内的文本元素，绝对定位一个相同的 DOM 版本的节点，提升可访问性，G 5.0 提供了 <a target="_blank" rel="noopener" href="https://g.antv.antgroup.com/plugins/a11y">g-plugin-a11y</a> 插件，可以很方便的实现该能力。</p>
<p><img src="/images/2024-12-31-e9cb749fdb99f7707ced0eb7ce6611d0e411e26cc7fab6eeb7bea4fa1ace52fc.png" alt="图 24"></p>
<p><img src="/images/2024-12-31-19cb6061b382c41b4a383c2fcde61f4fe35b45a9c0462d919a91f425612a8561.png" alt="图 25"></p>
<h3 id="wARxj">参考文章</h3>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/570318956">异步分片计算在腾讯文档的实践</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/608415829">浅谈 Canvas 渲染引擎</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/517190133/answer/2354923121">用 Canvas 实现虚拟列表的难点在哪里？</a></p>
<p><a target="_blank" rel="noopener" href="https://seblee.me/2011/02/html5-canvas-sprite-optimisation/">html5-canvas-sprite-optimisation</a></p>
<p><a target="_blank" rel="noopener" href="https://johnresig.com/blog/sub-pixel-problems-in-css/">Sub-Pixel Problems in CSS</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35966107">为何 Canvas 内元素动画总是在颤抖？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.html5rocks.com/en/tutorials/canvas/performance/">Improving HTML5 Canvas Performance</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas">Canvas 的优化</a></p>
<p><a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-text-4/#text-wrap">Text Wrapping</a></p>
<p><a target="_blank" rel="noopener" href="https://g.antv.antgroup.com/api/basic/text#%E5%A4%9A%E8%A1%8C%E5%B8%83%E5%B1%80">AntV/G 多行布局</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28855427">单机游戏画面设置中的抗锯齿是什么意思？画面中有锯齿又是什么效果？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.woshipm.com/pd/4878303.html">无障碍设计中的用户体验</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/antv/blog/ydsuqn">Canvas 局部渲染优化总结</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2024-12-31</span><i class="fa fa-comment-o"></i><a href="/2024/12/31/Canvas-%E6%96%87%E6%9C%AC%E6%B8%B2%E6%9F%93%E9%82%A3%E4%BA%9B%E4%BA%8B/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/tags/Canvas/" title="Canvas">Canvas </a></div></div></div></div><div style="margin:30px"><span class="leancloud-visitors" id="/2024/12/31/Canvas-文本渲染那些事/"><span class="post-meta-item-text" style="margin-right:5px">阅读量</span><i class="leancloud-visitors-count">-</i></span></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://www.lijinke.cn/2024/12/31/Canvas-文本渲染那些事/,李金珂的小屋,Canvas 文本渲染那些事,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/12/21/Server-Sent-Events-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81/" title="Server-Sent Events 服务端推送">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  //- notify: || false,
  //- verify:|| false,
  notify: true,
  verify: true,
  enableQQ: true,
  recordIP: true,
  app_id:'RBh7EcHesd4twgP5qIos38HM-gzGzoHsz',
  app_key:'f47a9Cg5ea9EVoPSs4KqfE6U',
  placeholder:'留下点什么?',
  path: window.location.pathname,
  avatar:'robohash',
  visitor: true,
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="https://unpkg.com/darkreader@4.9.32/darkreader.js"></script><script src="/pwa.js"></script><script src="/main.js"></script></body></html>