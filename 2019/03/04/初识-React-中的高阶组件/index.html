<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="李金珂,jkli@thoughtworks.com"><title>初识 React 中的高阶组件 · 李金珂的小屋</title><meta name="description" content="1. 前言
好久没有写文章了, 结合之前分享的资料, 今天介绍一下 React 中的 高阶组件
2. 什么是高阶组件
什么是 高阶组件 (Higher-Order-Component) , 说人话其实就是 组件外面在包一个组件, 用伪代码表示
123const 三明治 = 用刀切(面包(火腿),&amp;#"><meta name="keywords" content="Javascript,Node.js"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="李金珂的小屋"><meta name="theme-color" content="#31c27c"><meta name="icon" content="/logos/logo_192.png"><meta name="apple-touch-icon" content="/logos/logo_192.png"><meta name="apple-touch-startup-image" content="/logos/logo_512.png"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="manifest" href="/manifest.json"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/my.jpeg" style="width:127px;border-radius:50%;margin-bottom:20px;"><h3 title><a href="/">李金珂的小屋</a></h3><div class="description"><p>要想学仙术,哪能不吃苦</p></div></div></div><ul class="social-links"><li><a href="http://github.com/lijinke666"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">主页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友情链接</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/my.jpeg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>初识 React 中的高阶组件</a></h3></div><div class="post-content"><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><hr>
<p>好久没有写文章了, 结合之前分享的资料, 今天介绍一下 React 中的 高阶组件</p>
<h3 id="2-什么是高阶组件"><a href="#2-什么是高阶组件" class="headerlink" title="2. 什么是高阶组件"></a>2. 什么是高阶组件</h3><hr>
<p>什么是 高阶组件 (Higher-Order-Component) , 说人话其实就是 组件外面在包一个组件, 用伪代码表示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 三明治 = 用刀切(面包(火腿),&#123;</span><br><span class="line">    切几刀:<span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>用面包包裹 火腿 然后用 刀切一下, 变成了一个三明治,而三明治 就是最终生成的组件</p>
<h3 id="3-从高阶函数开始了解"><a href="#3-从高阶函数开始了解" class="headerlink" title="3. 从高阶函数开始了解"></a>3. 从高阶函数开始了解</h3><hr>
<p>在函数式编程里面,函数作为一等公民,函数可以作为<code>返回值</code>, 也可以作为<code>参数</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a</span>) =&gt;</span> (b) =&gt; a + b</span><br><span class="line"><span class="keyword">const</span> num = add(<span class="number">1</span>)(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure>
<p>这里的柯里化函数 add 接受一个值 <code>a</code>  然后返回一个新的函数, 新的函数同样接受一个值 <code>b</code>,最终 返回 a +b 的和,</p>
<p>理解了这点 之后 可以看出 所谓的 高阶组件 和 高阶函数 是一回事</p>
<h3 id="4-作用与基本原则"><a href="#4-作用与基本原则" class="headerlink" title="4. 作用与基本原则 ?"></a>4. 作用与基本原则 ?</h3><hr>
<blockquote>
<p>作用</p>
</blockquote>
<ul>
<li>代码复用</li>
<li>props 更改与组合</li>
<li>渲染劫持 通过判断条件决定渲染内容</li>
<li>装逼</li>
</ul>
<blockquote>
<p>基本原则</p>
</blockquote>
<ul>
<li>props 保持一致 : 在原有 props 上面添加一些新功能 尽量不让其受影响</li>
<li>可以任意灵活组合 : 多个高阶组件 可以组合在一起</li>
<li>给组件添加一个静态的displayName: 方便调试</li>
</ul>
<h3 id="5-实际例子"><a href="#5-实际例子" class="headerlink" title="5. 实际例子"></a>5. 实际例子</h3><hr>
<h4 id="5-1-组件包裹"><a href="#5-1-组件包裹" class="headerlink" title="5.1 组件包裹"></a>5.1 组件包裹</h4><blockquote>
<p>在原有组件的基础上包一层组件以便于添加一些元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> footer <span class="keyword">from</span> <span class="string">'./components/Footer'</span>;</span><br><span class="line"></span><br><span class="line">@footer(<span class="string">'哈哈'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">FooterPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>基本用法: 组件包裹<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default footer('哈哈')(FooterPage)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Footer.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getDisplayName &#125; <span class="keyword">from</span> <span class="string">'../utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> title =&gt; <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Footer</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(Component)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;footer className=<span class="string">"footer"</span>&gt;&#123;title&#125;&lt;<span class="regexp">/footer&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Component/</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>用<code>@</code> 装饰器的方式使用 高阶组件 第一个参数 是入参, 第二个参数 是接受到的包裹组件, 然后 返回一个 新的 <code>Componnet</code>, 高阶组件基本都是这种套路</p>
<p>代码很简单  在原有的组件继承上 添加了一个 <code>footer</code> 的标签, <code>displayName</code> 是为了方便调试, 因为如果重复使用 这个组件的话, 所有的名字 都是 <code>Footer</code> 到时候你都不知道对应的是哪个了, 所以加一个名字 方便看</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//utils.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getDisplayName = <span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> component.displayName || component.name || <span class="string">'Component'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<p><br><br><img src="https://www.lijinke.cn/lijinkeWeb-static/images/WX20180906-171540.png" style="max-width:100%"><br><br></p>
<h4 id="5-2-反向继承与渲染劫持"><a href="#5-2-反向继承与渲染劫持" class="headerlink" title="5.2 反向继承与渲染劫持"></a>5.2 反向继承与渲染劫持</h4><p>啥子事反向继承呢? 其实就是 继承需要包裹的组件 拿到它的 <code>state</code> 和 <code>props</code> 进行一个判断, 添加或者修改</p>
<p>而渲染劫持 同理 因为继承了之后 可以获取需要包裹的组件的生命周期 可以 手动的 判断是否需要 render, 而达到 渲染劫持的 效果</p>
<p>直接上代码, 实现一个 自动显示  <code>Loaindg...</code> 的高阶组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import autoLoading from &apos;./components/AutoLoading&apos;;</span><br><span class="line"></span><br><span class="line">@autoLoading((_, &#123; list &#125;) =&gt; list.length &lt; 1)</span><br><span class="line">export default class AutoLoadingPage extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    list: []</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;加载完成&lt;/h2&gt;</span><br><span class="line">        &#123;this.state.list.map((value, i) =&gt; &#123;</span><br><span class="line">          return &lt;p key=&#123;i&#125;&gt;&#123;value&#125;&lt;/p&gt;;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  fetch = () =&gt; &#123;</span><br><span class="line">    //模拟一个请求</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        list: [1, 2, 3]</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.fetch();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 页面加载之后 发起一个  <code>fetch</code> 请求 2s(模拟) 后 数据请求完毕, 页面正常渲染, 在加载完成之前 显示 loading…</p>
<p><br><br><img src="https://www.lijinke.cn/lijinkeWeb-static/images/WX20180906-171714.png" style="max-width:100%"><br><br></p>
<p><br><br><img src="https://www.lijinke.cn/lijinkeWeb-static/images/WX20180906-171738.png" style="max-width:100%"><br><br></p>
<p>是不是很神奇, 在业务逻辑中 并没有手动 <code>setState</code> 去改变 loading 的显示与隐藏,一切尽在 <code>autoLoading</code> 这个高阶组件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// AutoLoading.js</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; getDisplayName &#125; from &apos;../utils&apos;;</span><br><span class="line">import &apos;./styles.css&apos;;</span><br><span class="line"></span><br><span class="line">export default checkLoading =&gt; WrappedComponent =&gt; &#123;</span><br><span class="line">  //AutoLoading 继承 了 WrappedComponent 而不是 WrappedComponent 继承 AutoLoading</span><br><span class="line">  //所以叫反向继承</span><br><span class="line">  return class AutoLoading extends WrappedComponent &#123;</span><br><span class="line">    static displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)`;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      console.log(this.props);</span><br><span class="line">      if (checkLoading(this.props, this.state)) &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;div className=&quot;flex&quot;&gt;</span><br><span class="line">            &lt;div className=&quot;loading&quot;&gt;Loading...&lt;/div&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      return super.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>高阶组件 接受一个 checkLoading 的函数, 函数我们传入 <code>props</code> 和 <code>state</code>, 交给消费者调用, 只要其中一个返回 true<br>就是 显示  <code>Loading ...</code>, 否则则代表数据加载完毕, 调用父元素 <code>super.render()</code> 渲染页面, 这样一个通用的 加载高阶组件就完成了, 再也不用 每个页面手动去显示和隐藏加载效果了</p>
<h4 id="5-3-属性代理-实现一个低配版的-connect"><a href="#5-3-属性代理-实现一个低配版的-connect" class="headerlink" title="5.3 属性代理 : 实现一个低配版的 connect"></a>5.3 属性代理 : 实现一个低配版的 <code>connect</code></h4><p>平时开发中 使用 <code>React</code> 难免会和 <code>redux</code> 打交道, 用了 <code>redux</code> , 全家桶之一的 <code>react-redux</code> 可定再属性不过了, 其中有一个 <code>connect</code> 函数 就是经典的高阶组件的实现,通过 <code>connect</code> 之后 我们可以再当前组件 拿到全局的 store 的数据 和 dispatch, 显示我们来尝试实现一个简单的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//Connect.js</span><br><span class="line">import React, &#123; PureComponent &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; getDisplayName &#125; from &apos;../utils&apos;;</span><br><span class="line"></span><br><span class="line">const state = &#123;</span><br><span class="line">  name: &apos;js-catch-up&apos;,</span><br><span class="line">  type: &apos;connect&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const dispatch = action =&gt; &#123;</span><br><span class="line">  console.log(&apos;dispatch:&apos;, action);</span><br><span class="line">  alert(JSON.stringify(action, undefined, 2));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const action = name =&gt; &#123;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: &apos;SAY_HELLO&apos;,</span><br><span class="line">    name</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const actions = &#123;</span><br><span class="line">  setName: () =&gt; action</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default (mapStateToProps, mapDispatchToProps) =&gt; WrappedComponent =&gt; &#123;</span><br><span class="line">  return class Connect extends PureComponent &#123;</span><br><span class="line">    static displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)`;</span><br><span class="line"></span><br><span class="line">    state = state;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;WrappedComponent</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          &#123;...mapStateToProps(state)&#125;</span><br><span class="line">          &#123;...mapDispatchToProps(actions)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>高阶组件接受两个函数</p>
<ul>
<li><code>mapStateToProps()</code></li>
<li><code>mapDispatchToProps()</code></li>
</ul>
<p>这里我们模拟一个全局的  store 的 state<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;</span><br><span class="line">  name: &apos;js-catch-up&apos;,</span><br><span class="line">  type: &apos;connect&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>模拟一个 action</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const dispatch = action =&gt; &#123;</span><br><span class="line">  console.log(&apos;dispatch:&apos;, action);</span><br><span class="line">  alert(JSON.stringify(action, undefined, 2));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const action = name =&gt; &#123;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: &apos;SAY_HELLO&apos;,</span><br><span class="line">    name</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const actions = &#123;</span><br><span class="line">  setName: () =&gt; action</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最重要的是这里的, 啥子事属性代理, 将 当前的 props 传给 被包裹的组件, 然后将 消费者 传入的 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code> 生成的新 props 也传给 被包裹的 组件, 这样消费者(被包裹的组件的 props 里面 就有 connect 之后的东西了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      &#123;...this.props&#125;</span><br><span class="line">      &#123;...mapStateToProps(state)&#125;</span><br><span class="line">      &#123;...mapDispatchToProps(actions)&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import connect from &apos;./components/Connect&apos;;</span><br><span class="line"></span><br><span class="line">@connect(</span><br><span class="line">  (&#123; name, type &#125;) =&gt; (&#123;</span><br><span class="line">    name,</span><br><span class="line">    type</span><br><span class="line">  &#125;),</span><br><span class="line">  dispatch =&gt; (&#123;</span><br><span class="line">    setName: dispatch.setName()</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line">export default class Connect extends Component &#123;</span><br><span class="line">  onSetName = () =&gt; &#123;</span><br><span class="line">    this.props.setName(&apos;小明同学&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name, type &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h2&gt;属性代理&lt;/h2&gt;</span><br><span class="line">        &lt;div&gt; 名字 : &#123;type&#125; &lt;/div&gt;</span><br><span class="line">        &lt;p&gt; By : &#123;name&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.onSetName&#125;&gt;触发action&lt;/button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是 和 <code>react-redux</code> 用法一模一样对不对?<br>对你妈个猪脑壳, 哈哈 这只是一个低配版的,很多细节没实现, 为了便于理解(其实写不来), 比如 观察者模式,数据改变自动同步之类的都没做, 主要是理解一下用法</p>
<p><br><br><img src="https://www.lijinke.cn/lijinkeWeb-static/images/WX20180906-173759.png" style="max-width:100%"><br><br></p>
<h3 id="6-常见问题"><a href="#6-常见问题" class="headerlink" title="6. 常见问题"></a>6. 常见问题</h3><ul>
<li>disPlayName 问题<ul>
<li>高阶组件名字包裹之后需要加一个名字标识 方便调试</li>
</ul>
</li>
<li>组件包裹问题<ul>
<li>由于高阶组件会在当前组件包裹一层 这回带来 传递 props 麻烦的问题 要多传递一次</li>
</ul>
</li>
<li>无法获取静态方法<ul>
<li>高阶组件 可以获取到 被包裹组件的 props 和 state , 但是无法获取 静态方法 需要手动 拷贝 <a href="https://github.com/mridgway/hoist-non-react-statics" target="_blank" rel="noopener">https://github.com/mridgway/hoist-non-react-statics</a></li>
</ul>
</li>
</ul>
<h3 id="7-常见的-第三方库-的-高阶组件"><a href="#7-常见的-第三方库-的-高阶组件" class="headerlink" title="7. 常见的 第三方库 的 高阶组件"></a>7. 常见的 第三方库 的 高阶组件</h3><hr>
<ul>
<li><code>react-hot-loader</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;hot&#125; <span class="keyword">from</span> <span class="string">"react-hot-loader"</span></span><br><span class="line">@hot(<span class="built_in">module</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>antd-form</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Form&#125; <span class="keyword">from</span> <span class="string">"antd"</span></span><br><span class="line">@Form.create()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>react-redux</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span></span><br><span class="line">@connect(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    mapDispatchToProps</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-参考链接"><a href="#8-参考链接" class="headerlink" title="8. 参考链接"></a>8. 参考链接</h3><hr>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/24776678" target="_blank" rel="noopener">深入理解React 高阶组件</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29482095" target="_blank" rel="noopener">聊聊React高阶组件(Higher-Order Components)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29250138" target="_blank" rel="noopener">React高阶组件实践</a></li>
<li><a href="https://github.com/lijinke666/js-catch-up/react" target="_blank" rel="noopener">demo 代码</a></li>
</ul>
<h3 id="9-结语"><a href="#9-结语" class="headerlink" title="9. 结语"></a>9. 结语</h3><hr>
<p>高阶组件感觉也是个双刃剑, 用法了 会少很多模板代码, 比如 每个 page 都要 connect 可以搞一个高阶组件 统一 connect , 就比较方便, 但是 高阶组件会导致 组件多几层嵌套,在组件传值的时候回麻烦一些,加上隐藏了实现细节, 如果不是你写的高阶组件,不知道内部逻辑,调试的时候也是一大麻烦是, 溜了溜了,下班</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-03-04</span><i class="fa fa-comment-o"></i><a href="/2019/03/04/初识-React-中的高阶组件/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/tags/React/" title="React">React </a></div></div></div></div><div style="margin:30px"><span class="leancloud-visitors" id="/2019/03/04/初识-React-中的高阶组件/"><span class="post-meta-item-text" style="margin-right:5px">阅读量</span><i class="leancloud-visitors-count">1000000</i></span></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2019/03/04/初识-React-中的高阶组件/,李金珂的小屋,初识 React 中的高阶组件,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/03/04/再识-React-高阶组件/" title="再识 React 高阶组件">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/03/04/初识-Web-Component/" title="初识 Web Component">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.3.6/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:true || false,
  verify:true|| false,
  app_id:'RBh7EcHesd4twgP5qIos38HM-gzGzoHsz',
  app_key:'f47a9Cg5ea9EVoPSs4KqfE6U',
  placeholder:'说点啥子',
  path: window.location.pathname,
  avatar:'monsterid',
  visitor: true,
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>